package io.github.wycst.wast.json;

import io.github.wycst.wast.common.beans.DateFormatter;
import io.github.wycst.wast.common.reflect.ClassStrucWrap;
import io.github.wycst.wast.json.annotations.JsonProperty;
import io.github.wycst.wast.json.temporal.*;

import java.util.TimeZone;

/**
 * java.time support
 * <p>
 * Serialization using reflection
 * <p>
 * Localtime, localdate, localdatetime do not consider time zone
 *
 * @Author: wangy
 * @Date: 2022/8/13 15:08
 * @Description:
 */
public abstract class JSONTemporalSerializer extends JSONTypeSerializer {

    protected final Class<?> temporalClass;
    protected DateFormatter dateFormatter;
    protected final boolean useFormatter;

    protected JSONTemporalSerializer(Class<?> temporalClass, JsonProperty property) {
        checkClass(temporalClass);
        this.temporalClass = temporalClass;
        if (property != null) {
            String pattern = property.pattern().trim();
            if(pattern.length() > 0) {
                dateFormatter = DateFormatter.of(pattern);
            }
        }
        useFormatter = dateFormatter != null;
    }

    static JSONTypeSerializer getTemporalSerializerInstance(ClassStrucWrap classStrucWrap, JsonProperty property) {
        ClassStrucWrap.ClassWrapperType classWrapperType = classStrucWrap.getClassWrapperType();
        Class<?> temporalClass = classStrucWrap.getSourceClass();
        switch (classWrapperType) {
            case TemporalLocalDate: {
                return new TemporalLocalDateSerializer(temporalClass, property);
            }
            case TemporalLocalTime: {
                return new TemporalLocalTimeSerializer(temporalClass, property);
            }
            case TemporalLocalDateTime: {
                return new TemporalLocalDateTimeSerializer(temporalClass, property);
            }
            case TemporalZonedDateTime: {
                return new TemporalZonedDateTimeSerializer(temporalClass, property);
            }
            case TemporalOffsetDateTime:{
                return new TemporalOffsetDateTimeSerializer(temporalClass, property);
            }
            case TemporalInstant: {
                return new TemporalInstantSerializer(temporalClass, property);
            }
            default: {
                throw new UnsupportedOperationException();
            }
        }
    }

    // check
    protected abstract void checkClass(Class<?> temporalClass);

    protected void serialize(Object value, JSONWriter writer, JSONConfig jsonConfig, int indent) throws Exception {
        if (useFormatter) {
            writeTemporalWithTemplate(value, writer, jsonConfig);
        } else {
            writeDefault(value, writer, jsonConfig, indent);
        }
    }

    protected abstract void writeTemporalWithTemplate(Object value, JSONWriter writer, JSONConfig jsonConfig) throws Exception;

    /**
     * <p> 默认toString方式序列化
     * <p> 可重写优化，减少一次字符串的构建
     *
     * @param value
     * @param writer
     * @param jsonConfig
     * @param indent
     * @throws Exception
     */
    protected void writeDefault(Object value, JSONWriter writer, JSONConfig jsonConfig, int indent) throws Exception {
        String temporal = value.toString();
        CHAR_SEQUENCE_STRING.serialize(temporal, writer, jsonConfig, indent);
    }

    protected final static TimeZone getTimeZone(String zoneId) {
        return JSONGeneral.getTimeZone(zoneId);
    }
}
